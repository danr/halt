\documentclass[preprint,nocopyrightspace]{sigplanconf}

\usepackage{hcc-techreport}

\begin{document} 
\preprintfooter{\textbf{--- DRAFT ---}}


\newcommand{\Ct}{{\tt C}}
\newcommand{\CF}{{\tt CF}}
\newcommand{\True}{\mathop{True}}
\newcommand{\False}{\mathop{False}}
\newcommand{\Bool}{\mathop{Bool}}


%% \conferenceinfo{ICFP'08,} {September 22--24, 2008, Victoria, BC, Canada.}
%% \CopyrightYear{2008}
%% \copyrightdata{978-1-59593-919-7/08/09} 

\title{Haskell Contracts Technical Report}

\authorinfo{}{}{} %% TBD
%% \authorinfo{Dimitrios Vytiniotis \and Simon Peyton Jones}
%%   {Microsoft Research, Cambridge}
%%   {\{dimitris,simonpj\}@@microsoft.com}
%% \authorinfo{Jos\'{e} Pedro Magalh\~{a}es}
%%   {Utrecht University}
%%   {jpm@@cs.uu.nl}


\maketitle
\makeatactive

%% \begin{abstract}
%% The Glasgow Haskell Compiler is an optimizing
%% compiler that expresses and manipulates first-class equality proofs in
%% its intermediate language.  We describe a simple, elegant technique that
%% exploits these equality proofs to support \emph{deferred type errors}.
%% The technique requires us to treat equality proofs as possibly-divergent
%% terms; we show how to do so without losing either soundness or
%% the zero-overhead cost model that the programmer expects.
%% \end{abstract}

%% \category{D.3.3}{Language Constructs and Features}{Abstract data types}
%% \category{F.3.3}{Studies of Program Constructs}{Type structure}

%% \terms{Design, Languages}

%% \keywords{Type equalities, Deferred type errors, System FC}

\newcommand{\oln}[2]{\ol{#1}^{#2}}
\newcommand{\tmar}[2]{\mathop{tmar}_{#1}(#2)}
\newcommand{\tyar}[2]{\mathop{tyar}_{#1}(#2)}

\section{Syntax and semantics}
\label{s:intro}%
We will work with a polymorphic call-by-name calculus with algebraic data types, pattern matching, 
but where (i) polymorphism is only at top-level (a-la ML), (ii) functions are $\lambda$-lifted to 
the top-level and (iii) case expressions can only occur at top level. It is easy to convert source
Haskell to this intermediate form, which simplifies our translation and formal metatheory. The 
syntax of the language is given in Figure~\ref{fig:syntax}. 

\newcommand{\ar}{\alpha}

\begin{figure}\small
\[\begin{array}{l} 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Types}} \\
\tau,\sigma & ::=  & T\;\taus & \text{Datatypes} \\ 
            & \mid & a \mid \tau -> \tau 
\end{array}\\ \\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Expressions}} \\
e  & ::=  & x            & \text{Variables} \\ 
   & \mid & f[\ol{\tau}] & \text{Function variables} \\ 
   & \mid & K[\ol{\tau}](\ol{e}) & \text{Data constructors} \\
   & \mid & e\;e         & \text{Applications} \\
   & \mid & @BAD@        & \text{Runtime error} \\ 
\end{array}\\ \\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Definitions}} \\
D   & ::= & @fix@\;(f_1^{\ar_1},...,f_k^{\ar_k})\;@=@ \\ 
    &     & \quad\quad\quad\quad (\Lambda\as_1 @.@ \lambda{\oln{x{:}\tau}{\ar_1}} @.@ u_1,...,
                                                \Lambda\as_k @.@ \lambda{\oln{x{:}\tau}{\ar_k}} @.@ u_k) \\
%% %% d   & ::= & f |-> \Lambda\ol{a} @.@ \lambda\ol{x{:}\tau} @.@ u \\ 
u   & ::= & e \mid @case@\;e\;@of@\;\ol{K\;\ol{y} -> e} \\ 
%%D   & ::= & \cdot \mid D,d \\
\end{array}\\ \\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Datatype declarations}} \\
dec & ::= & @data@\;T\;\ol{a} = \ol{K\;\taus}
\end{array}\\ \\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Type environments and signatures}} \\
\Delta & ::=  & \cdot \mid \Delta,a \mid \Delta,x{:}\tau \\
\Sigma & ::=  & \cdot \mid \Sigma,T{:}n \mid \Sigma,f{:}\forall\ol{a} @.@ \tau \mid \Sigma,K^{\ar}{:}\forall\ol{a} @.@ \oln{\tau}{\ar} -> @T@\;\as
\end{array}\\ \\
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Auxiliary functions}} \\
constrs(\Delta,T) & = & \{ K \mid (K{:}\forall \as @.@ \taus -> T\;\as) \in \Delta \} \\
%% \tyar{D}{f} & = & n & \\ 
%%             & \multicolumn{3}{l}{\text{when}\; (f |-> \Lambda\oln{a}{n} @.@ \lambda\ol{x{:}\tau} @.@ u) \in D} \\
%% \tmar{D}{f} & = & n & \\ 
%%             & \multicolumn{3}{l}{\text{when}\; (f |-> \Lambda\ol{a} @.@ \lambda\oln{x{:}\tau}{n} @.@ u) \in D}
\end{array}\\ \\ 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Syntax of closed values}} \\
 v,w & ::= & K^\ar[\ol{\tau}](\oln{e}{\ar}) \mid f^\ar[\ol{\tau}]\;\oln{e}{m < \ar} \mid @BAD@ \\ \\ 
\end{array} \\
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Typed contracts}} \\
\Ct & ::=  & \{ (x{:}\tau) \mid e \}    & \text{Base contracts} \\ 
  & \mid &  (x{:}\Ct_1) -> \Ct_2        & \text{Arrow contracts} \\ 
  & \mid & \Ct_1 \& \Ct_2               & \text{Conjunctions}    \\ 
  & \mid & \CF                          & \text{Crash-freedom}  \\
\end{array}
\end{array}\]
\caption{Syntax}\label{fig:syntax}
\end{figure}


\begin{figure}\small
\[\begin{array}{c} 
\ruleform{\Sigma;\Delta |- \tau } \\ \\ 
\prooftree
         a \in \Delta
        ----------------{TVar}
         \Sigma;\Delta |- a  
        ~~~~ 
        \Sigma;\Delta |- \tau_1 \quad \Sigma;\Delta |- \tau_2
        ---------------------{TArr}
        \Sigma;\Delta |- \tau_1 -> \tau_2 
        ~~~~~ 
        \begin{array}{c}
          (T{:}n) \in \Sigma  \quad
          \Sigma;\Delta |- \taus
        \end{array}
        -------------------------{TData}
        \Sigma;\Delta |- T\;\oln{\tau}{n} 
\endprooftree \\ \\ 
\ruleform{\Sigma;\Delta |- e : \tau} \\ \\
\prooftree
  (f{:}\forall\oln{a}{n} @.@ \tau) \in \Sigma \quad \Sigma;\Delta |- \taus 
  --------------------------------------{TFVar}
  \Sigma;\Delta |- f[\oln{\tau}{n}] : \tau[\taus/\as]
  ~~~~ 
  (x{:}\tau) \in \Delta 
  --------------------------------------{TVar}
  \Sigma;\Delta |- x : \tau
  ~~~~~ 
  (K{:}\forall\oln{a}{n} @.@ \taus -> T\;\as) \in \Sigma \quad
  \Sigma;\Delta |- \taus \quad
  \Sigma;\Delta |- \ol{e : \tau}
  --------------------------------------{TCon}
  \Sigma;\Delta |- K[\oln{\tau}{n}](\ol{e}) : T\;\taus
  ~~~~~
  \phantom{\Delta}
  --------------------------------------{TBad}
  \Sigma;\Delta |- @BAD@ : \tau
  ~~~~
  \Sigma;\Delta |- e_1 : \sigma -> \tau \;\;
  \Sigma;\Delta |- e_2 : \sigma
  --------------------------------------{TApp}
  \Sigma;\Delta |- e_1\;e_2 : \tau
\endprooftree \\ \\ 
\ruleform{\Sigma;\Delta |- u : \tau} \\ \\
\prooftree
   \Sigma;\Delta |- e : \tau
   ---------------------------{TUTm}
    \Sigma;\Delta |- e : \tau
   ~~~~~ 
  \begin{array}{l}
  \Sigma;\Delta |- e : T\;\oln{\tau}{k} \quad
  constrs(\Sigma,T) = \ol{K} \\
  \text{for each branch}\;(K\;\oln{y}{l} -> e') \\
  \begin{array}{l}
           (K{:}\forall \cs @.@ \oln{\sigma}{l}{->}T\;\oln{c}{k}) \in \Sigma \text{ and }
           \Sigma;\ol{a},\ol{x{:}\tau},\ol{y{:}\sigma[\taus/\cs]} |- e'{:}\tau
  \end{array}
  \end{array}
  ----------------------------------------{TUCase}
  \Sigma;\Delta |- @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'}
\endprooftree \\ \\ 
\ruleform{ \Sigma |- D} \\ \\ 
\prooftree
   \begin{array}{l}
   \text{ for every} (f |-> \Lambda\oln{a}{n} @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in D \\
   \quad\quad (f{:}\forall\oln{a}{n} @.@ \oln{\tau}{m} -> \tau) \in \Sigma
   \text{ and }\Sigma;\as,\ol{x{:}\tau} |- u : \tau
   \end{array}
   ----------------------------------------------{TFDef}
   \Sigma |- D 
\endprooftree 
\end{array}\]
\caption{Typing relation}\label{fig:typing}
\end{figure}

%% \begin{figure}\small
%% \[\begin{array}{c} 
%% \ruleform{D |- value(e)} \\ \\
%% \prooftree
%%    \begin{array}{c}
%%    \tmar{D}{f} > m
%%    \end{array}
%%    ------------------------------------------------{VFun}
%%     D |- value(f[\oln{\tau}{n}]\;\oln{e}{m})
%%    ~~~~~
%%    ------------------------------------------------{VCon}
%%     D |- value(K[\ol{\tau}](\ol{e}))
%%    ~~~~ 
%%    ------------------------------------------------{VBad}
%%    D |- value(@BAD@)
%% \endprooftree
%% \end{array}\]
%% \caption{Values}\label{fig:typing}
%% \end{figure}


\begin{figure*}\small
\[\begin{array}{c} 
\ruleform{D |- e \Downarrow v} \\ \\
\prooftree

-------------------------------------{EVal}
D |- v \Downarrow v
~~~~
\begin{array}{c}
(f |-> \Lambda\ol{a} @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in D \\
D |- u[\ol{\tau}/\ol{a}][\ol{e}/\ol{x}] \Downarrow v
\end{array}
-------------------------------------{EFun}
D |- f[\ol{\tau}]\;\oln{e}{m} \Downarrow v
~~~~
\begin{array}{c}  
D |- e_1 \Downarrow v_1 \quad
D |- v_1\;e_2 \Downarrow w
\end{array}
------------------------------------------------{EApp}
D |- e_1\;e_2 \Downarrow w
~~~~
\begin{array}{c}  
D |- e_1 \Downarrow @BAD@ 
\end{array}
------------------------------------------------{EBadApp}
D |- e_1\;e_2 \Downarrow @BAD@
\endprooftree \\ \\ 
\ruleform{D |- u \Downarrow v} \\ \\
\prooftree
D |- e \Downarrow v
-------------------------------------{EUTm}
D |- e \Downarrow v
~~~~ 
\begin{array}{c}
D |- e \Downarrow K_i[\ol{\sigma}_i](\ol{e}_i) \quad
D |- e'_i[\ol{e}_i/\ol{y}_i] \Downarrow w
\end{array}
------------------------------------{ECase}
D |- @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'} \Downarrow w
~~~~
\begin{array}{c}
D |- e \Downarrow @BAD@ \\
\end{array}
------------------------------------{EBadCase}
D |- @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'} \Downarrow @BAD@
%% \begin{array}{c}
%% (f |-> \Lambda\ol{a} @.@ \lambda\oln{x{:}\tau}{m} @.@ @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'}) \in D \\
%% D |- e[\ol{\tau}/\ol{a}][\ol{e}/\ol{x}] \Downarrow @BAD@ \\
%% \end{array}
%% -------------------------------------{EBadCase}
%% D |- f[\ol{\tau}]\;\oln{e}{m} \Downarrow @BAD@
\endprooftree
\end{array}\]
\caption{Operational semantics}\label{fig:opsem}
\end{figure*}

\begin{lemma}[Subject reduction]
Assume $\Sigma |- D$ and $\Sigma;\cdot |- e : \tau$
If $D |- e \Downarrow w$ then $D |- value(w)$ and $\Sigma;\cdot |- w : \tau$.
\end{lemma}


\section{Contracts}

The syntax that we use for contracts is in Figure~\ref{fig:contract-syntax}. 
Contracts are typed (here, just monomorphically), and we give an operational 
semantics for contract satisfaction in the same figure. 

\begin{figure*}\small
\[\begin{array}{c} 
\ruleform{\Sigma;\Delta |- \Ct } \\ \\ 
\prooftree
\Sigma;\Delta,x{:}\tau |- e : \Bool
---------------------------------------{TCBase}
\Sigma;\Delta |- \{ (x{:}\tau) \mid e \} : \tau
~~~~ 
\begin{array}{c}
\Sigma;\Delta |- \Ct_1 : \tau \\
\Sigma;\Delta,(x{:}\tau) |- \Ct_2 : \tau' 
\end{array}
---------------------------------------{TCArr}
\Sigma;\Delta |- (x{:}\Ct_1) -> \Ct_2 : \tau -> \tau'
~~~~ 
\Sigma;\Delta |- \Ct_1 : \tau \quad \Sigma;\Delta |- \Ct_2 : \tau 
---------------------------------------{TCConj}
\Sigma;\Delta |- \Ct_1 \& \Ct_2 : \tau
~~~~ 
\phantom{\Gamma}
---------------------------------------{TCf}
\Sigma;\Delta |- \CF : \tau
\endprooftree \\ \\ 
\ruleform{\Sigma;D |- e \in \Ct} \\ \\
\prooftree
 D \not|- e \Downarrow 
-----------------------------------------------{ECDiv}
 \Sigma;D |- e \in \{ (x{:}\tau) \mid e' \}
 ~~~~
 D |- e'[e/x] \Downarrow \True 
-------------------------------------------{ECTrue}
 \Sigma;D |- e \in \{ (x{:}\tau) \mid e' \}
 ~~~~
 D \not|- e'[e/x] \Downarrow 
 ------------------------------------------{ECCDiv}
 \Sigma;D |- e \in \{ (x{:}\tau) \mid e' \} 
 ~~~~~
 \begin{array}{c} 
 \Sigma;\cdot |- \Ct_1 : \tau \\
 \text{for all } u, \Sigma;\cdot |- u : \tau ==> \Sigma;D |- e\;u \in \Ct_2[u/x]
 \end{array}
 --------------------------------------------{ECArr}
 \Sigma;D |- e \in (x{:}\Ct_1) -> \Ct_2 
 ~~~~
 \begin{array}{c}
 \Sigma,\cdot |- e : \tau  \\ 
 \text{for all } u, (\Sigma;\cdot |- u : \tau -> \Bool) /\ (@BAD@ \notin u) ==> \neg (D |- u\;e \Downarrow @BAD@)
 \end{array}
 --------------------------------------------------------------------------------------------{ECf}
 \Sigma;D |- e \in \CF 
 ~~~~~ 
 \Sigma;D |- e \in \Ct_1 \quad \Sigma;D |- e \in \Ct_2
 --------------------------------------------------------------------------------------------{ECConj}
 \Sigma;D |- e \in \Ct_1 \& \Ct_2
\endprooftree
\end{array}\]
\caption{Contract syntax and semantics}\label{fig:contract-syntax}
\end{figure*}


\section{First-order logic}
\newcommand{\lcf}[1]{\textsf{cf}(#1)}
\newcommand{\lncf}[1]{\neg\textsf{cf}(#1)}
\newcommand{\unr}{\mathop{unr}}
\newcommand{\bad}{\mathop{bad}}
\newcommand{\sel}[2]{\mathop{sel\_#1\!\_#2}}
\newcommand{\ctrans}[3]{{\cal C}[\![#3]\!]_{#2}^{#1}}
\newcommand{\etrans}[3]{{\cal E}[\![#3]\!]_{#2}^{#1}}
\newcommand{\utrans}[3]{{\cal U}[\![#3]\!]_{#2}^{#1}}
\newcommand{\dtrans}[2]{{\cal D}[\![#2]\!]^{#1}}
\newcommand{\Dtrans}[2]{{\cal D}[\![#2]\!]^{#1}}

\begin{figure}
\[\begin{array}{c} 
\begin{array}{lrll}
\multicolumn{3}{l}{\text{Terms}} \\
  s,t & ::=  & f(\ol{t}) \mid K(\ol{t}) \mid x & \text{Functions, constructors, vars} \\
      & \mid & \sel{K}{i}                      & \text{Constructor selectors} \\ 
      & \mid & app(t,s)                        & \text{Application} \\
      & \mid & \unr \mid \bad                  & \text{Unreachable, bad} \\ \\ 
\multicolumn{3}{l}{\text{Formulae}} \\ 
 \phi & ::=  & \lcf{t}    & \text{Provably cannot cause crash} \\
%%      & \mid & \lncf{t}   & \text{Can provably cause crash} \\
      & \mid & t_1 = t_2  & \text{Equality} \\ 
      & \mid & \phi \land \phi \mid \phi \lor \phi \mid \neg \phi \\
      & \mid & \forall x @.@ \phi \mid \exists x @.@ \phi \\ \\ 
\multicolumn{3}{l}{\text{Abbreviations}} \\ 
\multicolumn{4}{l}{app(t,\oln{s}{n}) = (\ldots(app(t,s_1),\ldots s_n)\ldots)}
\end{array}
\end{array}\]
\caption{Image of translation into FOL}\label{fig:fol-image}
\end{figure}

\newcommand{\elab}[1]{\rightsquigarrow \formula{#1}}

\begin{figure}\small
\[\begin{array}{c} 
\ruleform{\etrans{\Sigma}{\Delta}{e} = \formula{t} } \\ \\
\prooftree
  \begin{array}{c}
  (f{:}\forall\oln{a}{n} @.@ \tau) \in \Sigma
  \end{array}
  --------------------------------------{TFVar}
  \etrans{\Sigma}{\Delta}{f[\oln{\tau}{n}]} = \formula{x_{f}}
  ~~~~ 
  (x{:}\tau) \in \Delta 
  --------------------------------------{TVar}
  \etrans{\Sigma}{\Delta}{x} = \formula{x}
  ~~~~~ 
  \begin{array}{c}
  (K{:}\forall\oln{a}{n} @.@ \ol{\tau} -> T\;\as) \in \Sigma \quad
  \ol{\etrans{\Sigma}{\Delta}{e} = \formula{t}}
  \end{array}
  --------------------------------------{TCon}
  \etrans{\Sigma}{\Delta}{K[\oln{\tau}{n}](\ol{e})} = \formula{K(\ol{t})}
  ~~~~~
  \phantom{\Delta}
  --------------------------------------{TBad}
  \etrans{\Sigma}{\Delta}{@BAD@} = \formula{\bad}
  ~~~~
  \etrans{\Sigma}{\Delta}{e_1} = \formula{t_1} \quad 
  \etrans{\Sigma}{\Delta}{e_2} = \formula{t_2}
  --------------------------------------{TApp}
  \etrans{\Sigma}{\Delta}{e_1\;e_2} = \formula{app(t_1,t_2)}
\endprooftree \\ \\ 
\ruleform{\utrans{\Sigma}{\Delta}{t \sim u} = \formula{\phi}} \\ \\ 
\prooftree
   \etrans{\Sigma}{\Delta}{e} = \formula{t}
   ----------------------------------------{TUTm}
   \utrans{\Sigma}{\Delta}{s \sim e } = \formula{s = t} 
   ~~~~~
  \begin{array}{l}
  \etrans{\Sigma}{\Delta}{e} = \formula{t} \quad
  constrs(\Sigma,T) = \ol{K} \\
  \text{for each branch}\;(K\;\oln{y}{l} -> e') \\
  \begin{array}{l}
           (K{:}\forall \cs @.@ \oln{\sigma}{l} -> T\;\oln{c}{k}) \in \Sigma \text{ and }
           \etrans{\Sigma}{\Delta,\ol{y{:}\sigma[\taus/\cs]}}{e'} = \formula{ t_K }
  \end{array}
  \end{array}
  ------------------------------------------{TUCase}
  \begin{array}{l}
  \utrans{\Sigma}{\Delta}{s \sim @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'}} = \\
  \;\;\formula{ \begin{array}{l} (t = \bad /\ s = \bad)\;\lor\;(s = \unr)\;\lor \\
                                \quad      \bigvee(t = K(\oln{{\sel{K}{i}}(t)}{}) \land
                                           s = t_K[\oln{\sel{K}{i}(t)}{}/\ol{y}])
                   \end{array}
           }
  \end{array}
\endprooftree \\ \\ 
\ruleform{ \Dtrans{\Sigma}{D} = \formula{\phi}} \\ \\ 
\prooftree
     \begin{array}{l}       
       \text{for each} (f |-> \Lambda\oln{a}{n} @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in D \\ 
          \quad \utrans{\Sigma}{\as,\ol{x{:}\tau}}{f(\ol{x}) \sim u} = \formula{\phi}
     \end{array}
     --------------------{TDefs}
     \Dtrans{\Sigma}{D} = \formula{\phi}
\endprooftree 

\end{array}\]
\caption{Typed elaboration to FOL terms}\label{fig:etrans}
\end{figure}

%% \begin{figure}\small
%% \[\begin{array}{c} 
%% %% \ruleform{ \dtrans{\Sigma}{d} = \formula{\phi} } \\ \\
%% %% \prooftree
%% %%   \begin{array}{c}
%% %%   (f{:}\forall\oln{a}{n} @.@ \oln{\tau}{m} -> \tau) \in \Sigma \quad 
%% %%   \etrans{\Sigma}{\ol{a},\ol{x{:}\tau}}{e} = \formula{t}
%% %%   \end{array}
%% %%   -------------------------------------------------------------------{TFDef}
%% %%   \dtrans{\Sigma}{(f |-> \Lambda\oln{a}{n} @.@ \lambda\oln{x{:}\tau}{m} @.@ e)} =  \formula{ (\forall x @.@ f(\oln{x}{m}) = t) }
%% %%   ~~~~~ 
%% %%   \begin{array}{l}
%% %%   (f{:}\forall\oln{a}{n} @.@ \oln{\tau}{m} -> \tau) \in \Sigma \quad 
%% %%   \etrans{\Sigma}{\ol{a},\ol{x{:}\tau}}{e} = \formula{t} \\
%% %%   constrs(\Sigma,T) = \ol{K} \\
%% %%   \text{for each branch}\;(K\;\oln{y}{l} -> e') \\
%% %%   \quad \begin{array}{l}
%% %%            (K{:}\forall \cs @.@ \oln{\sigma}{l} -> T\;\oln{c}{k}) \in \Sigma \\
%% %%            \etrans{\Sigma}{\ol{a},\ol{x{:}\tau},\ol{y{:}\sigma[\taus/\cs]}}{e'} = \formula{ t_K }
%% %%         \end{array}
%% %%   \end{array}
%% %%   -------------------------------------------------------------------{TCaseDef}
%% %%   \begin{array}{l}
%% %%    \dtrans{\Sigma}{(f |-> \Lambda\oln{a}{n} @.@ \lambda\oln{x{:}\tau}{m} @.@ @case@\;e\;@of@\;\ol{K\;\ol{y} -> e'})} = \\
%% %%    \quad \formula{ \begin{array}{lll} \forall \oln{x}{m} @.@ & \hspace{-7pt} (t = \bad /\ f(\ol{x}) = \bad)\; \lor \\ 
%% %%                                                                     & \hspace{-7pt}(f(\ol{x}) = \unr)\;\lor \\ 
%% %%                                                                     & \hspace{-7pt}(\bigvee(t = K(\oln{{\sel{K}{i}}(t)}{i\in 1..l})\;/\ \\
%% %%                                                                     & \hspace{-5pt}\quad f(\ol{x}) = t_K[\oln{\sel{K}{i}(t)}{i\in 1..l}/\ol{y}]))
%% %%                                                  \end{array}
%% %%                         }
%% %% \end{array}
%% %% \endprooftree  \\ \\ 
%% \end{array}\]
%% \caption{Definition elaboration to FOL}\label{fig:typing}
%% \end{figure}


\begin{figure}\small
\[\begin{array}{c} 
\ruleform{\ctrans{\Sigma}{\Delta}{e \in \Ct} = \formula{\phi}} \\ \\ 
\prooftree
  \begin{array}{c}
   \etrans{\Sigma}{\Delta}{e} = \formula{t} \quad
   \etrans{\Sigma}{\Delta,(x{:}\tau)}{e'} = \formula{t'}
  \end{array}
  ------------------------------------------{CTransBase}
  \begin{array}{l}
   \ctrans{\Sigma}{\Delta}{e \in \{(x{:}\tau) \mid e' \}} = \\
  %% \Sigma;\Delta |- e \in \{(x{:}\tau \mid e' \}
  \;\;\formula{(t{=}\unr) \lor (t'[t/x] = \unr) \lor (t'[t/x] = \True)}
  \end{array}
  ~~~~~ 
  \begin{array}{c}
  \ctrans{\Sigma}{\Delta,(x{:}\tau)}{x \in \Ct_1} {=} \formula{\phi_1} \quad
  \ctrans{\Sigma}{\Delta,(x{:}\tau)}{e\;x \in \Ct_2} {=} \formula{\phi_2}
  \end{array} 
  ------------------------------------------{CTransArr}
  \begin{array}{l} 
  \ctrans{\Sigma}{\Delta}{e \in (x{:}\Ct_1) -> \Ct_2} = 
  \formula{\forall x @.@ \neg \phi_1 \lor \phi_2} 
  \end{array}
  ~~~~~
  \begin{array}{c}
  \ctrans{\Sigma}{\Delta}{e \in \Ct_1} = \formula{ \phi_1} \quad
  \ctrans{\Sigma}{\Delta}{e \in \Ct_2} = \formula{ \phi_2}
  \end{array}
  ------------------------------------------{CTransConj}
  \ctrans{\Sigma}{\Delta}{e \in \Ct_1 \& \Ct_2} = \formula{ \phi_1 /\ \phi_2}
  ~~~~~
  \etrans{\Sigma}{\Delta}{e} =  \formula{t}
  -------------------------------------------{CTransCf}
  \ctrans{\Sigma}{\Delta}{e \in \CF} = \formula{\lcf{t}}
 \endprooftree 
%% \\ \\ 
%% \ruleform{\Sigma;\Delta |- e \notin \Ct \elab{ \phi} } \\ \\
%% \prooftree
%%   \begin{array}{c}
%%    \Sigma;\Delta |- e : \tau \elab{ t}  \quad
%%    \Sigma;\Delta,(x{:}\tau) |- e' : \Bool \elab{ t'}
%%   \end{array}
%%   ------------------------------------------{CNTransBase}
%%   \begin{array}{l}
%%   \Sigma;\Delta |- e \notin \{(x{:}\tau) \mid e' \} 
%%   \elab{(t'[t/x] = \bad) \lor (t'[t/x] = \False)}
%%   \end{array}
%%   ~~~~~ 
%%   \Sigma;\cdot |- \Ct_1 : \tau
%%   ------------------------------------------{CNTransArr}
%%   \begin{array}{l} 
%%   \Sigma;\Delta |- e \notin (x{:}\Ct_1) -> \Ct_2 
%%   \elab{\exists x @.@ (\Sigma;\Delta,(x{:}\tau) |- x \in \Ct_1) /\ (\Sigma;\Delta,(x{:}\tau) |- e\;x \notin \Ct_2)}
%%   \end{array}
%%   ~~~~~
%%   \begin{array}{c}
%%   \Sigma;\Delta |- e \notin \Ct_1 \elab{ \phi_1} \quad
%%   \Sigma;\Delta |- e \notin \Ct_2 \elab{ \phi_2}
%%   \end{array}
%%   ------------------------------------------{CNTransConj}
%%   \Sigma;\Delta |- e \notin \Ct_1 \& \Ct_2 \elab{ \phi_1 \lor \phi_2}
%%   ~~~~
%%   \Sigma;\Delta |- e : \tau \elab{ t}
%%   -------------------------------------------{CNTransCf}
%%   \Sigma;\Delta |- e \notin \CF \elab{ \lncf{t}}
%%  \endprooftree
\end{array}\]
\caption{Baseline contract elaboration}\label{fig:typing}
\end{figure}


\section{Prelude}
\newcommand{\ys}{\ol{y}}
\newcommand{\Th}[2]{{\cal T}_{#1,#2}}

In addition to contract translation we have an axiomatization in Figure~\ref{fig:prelude}.


\begin{figure}\small
\[\begin{array}{c}
\ruleform{\Th{\Sigma}{D}} \\ 
\begin{array}{lll} 
 \textsc{AxDisjA} & \formula{\bad \neq \unr}  \\ 
 \textsc{AxDisjB} & \formula{\forall \oln{x}{n}\oln{y}{m} @.@ K(\ol{x}) \neq J(\ol{y})} \\ 
                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\ 
                  & \text{ and } (J{:}\forall\as @.@ \oln{\tau}{m} -> S\;\as) \in \Sigma \\
 \textsc{AxDisjC} & \formula{(\forall \oln{x}{n} @.@ K(\ol{x}) \neq \unr \land K(\ol{x}) \neq \bad)} \\ 
                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\ \\
 \textsc{AxAppA}  & \formula{\forall \oln{x}{n} @.@ f(\ol{x}) = app(x_f,\xs)} \\
                  & \text{ for every } (f |-> \Lambda\as @.@ \lambda\oln{x{:}\tau}{n} @.@ u) \in D \\
 %% \textsc{AxAppB}  & \formula{\forall \oln{x}{n} @.@ K(\ol{x}) = app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots)} \\
 %%                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\
 \textsc{AxAppC}  & \formula{\forall x, app(\bad,x) = \bad \; /\ \; app(\unr,x) = \unr}    \\ \\
 %% Not needed: we can always extend partial constructor applications to fully saturated and use AxAppC and AxDisjC
 %% \textsc{AxPartA} & \formula{\forall \oln{x}{n} @.@ app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots) \neq \unr} \\
 %%                  & \formula{\quad\quad \land\; app(\ldots (app(x_K,x_1),\ldots,x_n)\ldots) \neq \bad} \\
 %%                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{m} -> T\;\as) \in \Sigma \text{ and } m > n \\
 \textsc{AxPartB} & \formula{\forall \oln{x}{n} @.@ app(x_f,\xs) \neq \unr} \\
                  & \formula{\quad\land\; app(x_f,\xs) \neq \bad} \\
                  & \formula{\quad\land\; \forall \oln{y}{k} @.@ app(x_f,\xs) \neq K(\ol{y})} \\
                  & \text{ for every } (f |-> \Lambda\as @.@ \lambda\oln{x{:}\tau}{m} @.@ u) \in D  \\
                  & \text{ and every } (K{:}\forall\as @.@ \oln{\tau}{k} -> T\;\as) \in \Sigma \text{ and } m > n  \\ \\ 
 \textsc{AxInj}   & \formula{\forall \oln{y}{n} @.@ \sel{K}{i}(K(\ys)) = y_i} \\ 
                  & \text{for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \text{ and } i \in 1..n \\ \\
 \textsc{AxCfA}   & \formula{\lcf{\unr} /\ \lncf{\bad}} \\
 \textsc{AxCfB}   & \formula{\forall \oln{x}{n} @.@ \lcf{K(\ol{x})} <=> \bigwedge\lcf{\ol{x}}} \\
                  & \text{ for every } (K{:}\forall\as @.@ \oln{\tau}{n} -> T\;\as) \in \Sigma \\
 \textsc{AxCfC}   & \formula{\forall x y @.@ \lcf{x} /\ \lcf{y} => \lcf{app(x,y)}} \\ \\ 
\end{array}
\end{array}\]
\caption{Prelude theory}\label{fig:prelude}
\end{figure}

\section{Basic facts about operational semantics}
%% Gadgets of domain theory 
\newcommand{\roll}{\mathsf{roll}}
\newcommand{\unroll}{\mathsf{unroll}}
\newcommand{\bind}{\mathsf{bind}}
\newcommand{\ret}{\mathsf{ret}}
\newcommand{\dlambda}{\mathsf{\lambda}}
\newcommand{\curry}{\mathsf{curry}}
\newcommand{\eval}{\mathsf{eval}}
\newcommand{\uncurry}{\mathsf{incurry}}
\newcommand{\dapp}{\mathsf{app}}
\newcommand{\inj}[1]{\mathsf{inj}_{#1}}

\begin{lemma}[Value determinacy]
If $\Sigma;\cdot |- v : \tau$ and 
$\Sigma |- D$ and $D |- value(v)$ and $D |- v \Downarrow w$ then $ v = w $.
\end{lemma}

\begin{lemma}[Determinacy of evaluation]
If $\Sigma;\cdot |- e : \tau$ and 
$\Sigma |- D$ and $\Sigma;\cdot |- e \Downarrow v_1$ and $\Sigma;\cdot |- e \Downarrow v_2$ then
$v_1 = v_2$.
\end{lemma}

\begin{lemma}[Big-step soundness]
If $\Sigma;\cdot |- e : \tau$ and 
$\Sigma |- D$ and $\Sigma;\cdot |- e \Downarrow v$ then $D |- value(v)$ and $\Sigma;\cdot |- v : \tau$.
\end{lemma}


\section{Denotational semantics}
\newcommand{\unitcpo}{{\sf{\bf 1}}}

For a well-formed signature $\Sigma$, we define the strict bi-functor on cpos, below, 
assuming that $K_1\ldots K_k$ are all the constructors in $\Sigma$: 
\[\begin{array}{lclll}
  F_{\Sigma}(D^{-},D^{+}) & = & ( \quad{\prod_{\alpha_1}{D^{+}}} & K_1^{\ar_1} \in \Sigma \\
                      & + & \;\quad\ldots                    & \ldots \\
                      & + & \;\quad{\prod_{\alpha_k}{D^{+}}} & K_k^{\ar_k} \in \Sigma \\ 
                      & + & \;\quad(D^{-} =>_c D^{+}) \\
                      & + & \;\quad\unitcpo_{bad} \quad )_{\bot}
\end{array}\] 
The notation $\prod_{n}{D}$ abbreviates $n$-ary products ($\unitcpo$ if $n = 0$). The product
and sum constructions are standard, and not strict. The notation $C =>_c D$ denotes the cpo 
induced by the space of continus functions from the cpo $C$ to the cpo $D$. We use $\unitcpo_{bad}$ 
notation to simply denote a single-element cpo -- the $bad$ subscript is just there for readability. 

The notation $D_\bot$ is {\em lifting}, which is a monad, equipped with the following two continuous functions.
\[\begin{array}{l}
   \ret   : D =>_c D_\bot \\ 
   \bind_{f : D =>_c E_\bot} : D_\bot =>_c E_\bot
\end{array}\]
with the obvious definitions.

Moreover, the following continuous operations are defined:
\[\begin{array}{l} 
   \curry_{f : D\times E =>_c F} : D =>_c (E =>_C F) \\ 
   \eval : (E =>_c D)\times E =>_c D 
\end{array}\] 
for any cpos $D, E, F$.

\begin{lemma} There exists a solution to the domain-recursive equation induced by $F_{\Sigma}$, call it $D_{\infty}$.
Moreover, let a value-domain: $V_{\infty}$ be defined as:
    \[\begin{array}{ll}
             \quad\;{\prod_{\alpha_1}{D_{\infty}}} & K_1^{\ar_1} \in \Sigma \\
             \; + \;\ldots                    & \ldots \\
             \; + \;{\prod_{\alpha_k}{D_{\infty}}} & K_k^{\ar_k} \in \Sigma \\ 
             \; + \;(D_{\infty} =>_c D_{\infty}) \\
             \; + \;\unitcpo_{bad} \quad
    \end{array}\]
Then the following functions also exist, each being the inverse of the other (i.e. composing to the identity 
function on the appropriate cpo):
\[\begin{array}{l}
  \roll : (V_{\infty})_\bot =>_c D_{\infty} \\ 
  \unroll : D_{\infty} =>_c (V_{\infty})_\bot
\end{array}\] 
\end{lemma}
\begin{proof} By standard results in domain theory [Pitts, Freyd]. \end{proof}

\paragraph{Definability of application}
We may now {\em define} application $\dapp : D_\infty \times D_\infty =>_c D_\infty$ as: 
{\setlength{\arraycolsep}{2pt}
\[\begin{array}{rcll}
   \dapp & = & \multicolumn{2}{l}{\dlambda d @.@ \roll(\bind_g (\unroll (\pi_1(d))))} \\
   \text{ where } g & = &  [ & \bot : \prod_{\ar_1}{D_\infty} =>_c D_\infty =>_c (V_\infty)_\bot \\
                    &   &  , & \ldots \\
                    &   &  , & \bot : \prod_{\ar_k}{D_\infty} =>_c D_\infty =>_c (V_\infty)_\bot \\
                    &   &  , & \dlambda d' @.@ \unroll(d'(\pi_2(d))) \\
                    &   &  , & \dlambda b @.@ \dlambda d. \ret(\inj{bad}(b))\hspace{2pt} ] 
\end{array}\]}%
where we have used notation $\langle , \rangle$ to introduce pairs. and $[\ldots]$ to eliminate ($n$-ary) sums.
The projections $\pi_1$ and $\pi_2$ are the obvious continues projections from the binary product space of $D_{\infty}$. 
We use notation $\inj{K}$ to denote the continues map that injects some $\alpha$-ary product of $D_{\infty}$ into the sum $V_{\infty}$.
We use notation $\inj{->}$ to denote the continuous injection of $(D_{\infty} =>_c D_{\infty})$ into $V_{\infty}$ and finally, 
$\inj{bad}$ for the unit injection into $V_{\infty}$.


\subsection{Interpretations}
\newcommand{\VarCpo}{\textit{Var}}
\newcommand{\FVarCpo}{\textit{FunVar}}
\newcommand{\interp}[3]{[\![#1]\!]_{\langle {#2},{#3}\rangle}}
\newcommand{\dbrace}[1]{[\![#1]\!]}


We have now defined the domain-theoretic language and combinators that we will use. 
We proceed to give interpretations of terms and definitions. 

First, the denumerable set of term variable names $x_1,\ldots$ induces a discrete 
cpo $\VarCpo$  and the denumerable set of function variable names $f_1,\ldots$ induces a discrete 
cpo $\FVarCpo$. We define, {\em semantic term environments} to be the cpo $(\VarCpo =>_c D_{\infty})$, 
and {\em semantic function environments} to be the cpo $(\FVarCpo =>_c D_{\infty})$. 

Next we will define $[\![e]\!]$ as a continuous map: 
\[ 
    (\FVarCpo =>_c D_{\infty}) \times (\VarCpo =>_c D_{\infty}) =>_c D_{\infty}
\] 
Below, for a given term $e$ and semantic environments $\rho : \VarCpo =>_c D_{\infty}$ and 
$\sigma : \FVarCpo =>_c D_{\infty}$ we let: 
\[\begin{array}{rcll}
  \interp{x}{\sigma}{\rho} & = & \rho(x) \\ 
  \interp{f\;[\taus]}{\sigma}{\rho} & = & \sigma(f) \\
  \interp{K\;[\taus]\;(\ol{e})}{\sigma}{\rho} & = & \roll(\ret(\inj{K}(\langle\interp{\ol{e}}{\sigma}{\rho}\rangle))) \\ 
  \interp{e_1\;e_2}{\sigma}{\rho} & = & \dapp(\langle \interp{e_1}{\sigma}{\rho}, \interp{e_2}{\sigma}{\rho}\rangle) \\ 
  \interp{@BAD@}{\sigma}{\rho} & = & \roll(\ret(\inj{bad}1))
\end{array}\]
A small technical remark: we write this with pattern matching notation (instead of using $\pi_1$ for projecting 
out $\sigma$ and $\pi_2$ for projecting out $\rho$) but that is fine, since $\times$ is not a lifted construction. 

Proceeding in the same way for $[\![u]\!]$ we get:
\[\setlength{\arraycolsep}{2pt}
  \begin{array}{rcll}
  \interp{e}{\sigma}{\rho} & = & \multicolumn{2}{l}{\interp{e}{\sigma}{\rho}} \\ 
  \interp{@case@\;e\;@of@ \ol{ K\;\ys -> e_K}}{\sigma}{\rho} & = & \multicolumn{2}{l}{\roll(\bind_{g} (\unroll(\interp{e}{\sigma}{\rho})))} \\ \\ 
  \text{ where } g  & = & [ & h_{K_1} \\
                    &   & , & \ldots \\
                    &   & , & h_{K_k} \\
                    &   & , & \bot \\ 
                    &   & , & \dlambda b @.@ \ret(b) \hspace{2pt} ] \\ 
              h_{K} & =  & \multicolumn{2}{l}{\dlambda d @.@ \unroll(\interp{e_K}{\sigma}{\rho, \ol{y |-> \pi_i(d)}})} \\ 
                    &   & \multicolumn{2}{l}{\text{when } K \text{ is in the branches}} \\
              h_{K}  & = & \multicolumn{2}{l}{\bot } \\ 
                    &   & \multicolumn{2}{l}{\text{otherwise}}                  
\end{array}\]

Finally, for a definition $D$ we may define a continuous map:
\[ 
        [\![D]\!] : (\FVarCpo =>_c D_{\infty}) =>_c (\FVarCpo =>_c D_{\infty}) 
\]
Let $D$ be 
\[\begin{array}{l} 
     @fix@\;(f_1^{\ar_1},...,f_k^{\ar_k})\;@=@\; 
     (\lambda{\oln{x{:}\tau}{\ar_1}} @.@ u_1,...,
                   \Lambda\as_k @.@ \lambda{\oln{x{:}\tau}{\ar_k}} @.@ u_k) 
\end{array}\] 
Then
\[\begin{array}{l}  
   [\![D]\!]_{\sigma} f =  \\ 
     \qquad\text{ if } (f |-> \Lambda\as @.@ \lambda\oln{x:\tau}{n} @.@ u) \in D \\
     \qquad\text{ then } \\
     \qquad\quad\quad \roll(\ret(\inj{->}(\dlambda d_1 @.@ \ldots  \\
     \qquad\quad\quad\quad \roll(\ret(\inj{->}(\dlambda d_n @.@ \interp{u}{\sigma}{\ol{x |-> d}})))\ldots))) \\
     \qquad \text{ else } \bot
\end{array}\]

Since $[\![D]\!]$ is continuous, its limit exists and is an element of the cpo $\FVarCpo =>_c D_{\infty}$, 
we will call this $\dbrace{D}^{\infty}$ in what follows.


\begin{lemma}[Type irrelevance]
It is the case that $\interp{u}{\sigma}{\rho} = \interp{u[\ol{\tau}/\as]}{\sigma}{\rho}$ 
and $\interp{e}{\sigma}{\rho} = \interp{e[\ol{\tau}/\as]}{\sigma}{\rho}$.
\end{lemma}
\begin{proof} Straightforward induction. \end{proof}

\begin{lemma}[Substitutivity]
If $\Sigma;\Delta,x{:}\tau |- e : \tau$ and $\rho$ is a semantic environment 
and $\Sigma;\Delta |- e' : \tau'$ then 
\[ \interp{e}{\sigma}{\rho,x |-> \interp{e'}{\sigma}{\rho}} = \interp{e[e'/x]}{\sigma}{\rho} \]
and if $\Sigma;\Delta,x{:}\tau |- u : \tau$ then 
\[ \interp{u}{\sigma}{\rho,x |-> \interp{e'}{\sigma}{\rho}} = \interp{u[e'/x]}{\sigma}{\rho} \]
\end{lemma}

\begin{lemma}[Denotational semantics soundness]
Assume $\Sigma |- D$. 
\begin{itemize*} 
  \item If $\Sigma;\cdot |- e : \tau$ and $D |- e \Downarrow v$ then $\interp{e}{\sigma_{D}}{\cdot} = \interp{v}{\dbrace{D}^{\infty}}{\cdot}$.
  \item If $\Sigma;\cdot |- u : \tau$ and $D |- u \Downarrow v$ then $\interp{u}{\sigma_{D}}{\cdot} = \interp{v}{\dbrace{D}^{\infty}}{\cdot}$.
\end{itemize*} 
\end{lemma} 
\begin{proof} The two statements are proved simultaneously by induction on the height of the evaluation derivation, making use
of the type irrelevance lemma and substitutivity.
\end{proof}

\subsection{Adequacy}
The goal of this section is to prove the following lemma: 

\begin{theorem}[Computational adequacy]
Assume $\Sigma |- D$ and $\Sigma;\cdot |- e : \tau$. Then, 
if $\unroll(\interp{e}{\dbrace{D}^{\infty}}{\cdot}) = \ret(d)$ for some 
element $d$ of $V_{\inf}$ then there exists a $v$ such 
that $D |- e \Downarrow v$.
\end{theorem}

To do this we define a {\em logical relation} first between semantics 
and syntax. Let $Rel \subseteq D_\infty \times Expr$ be the space of 
{\em admissible} and {\em equality-respecting} relations between 
denotations and closed (non-necessarily well-typed) terms. Some explanations:
\begin{itemize}
  \item $R \in Rel$ is {\em admissible} iff whenever 
  $R(d_i,e)$ for every element of a chain $d_1\ldots$ then also $R(\sqcup_{\omega}d_i,e)$. 
  \item $R \in Rel$ is {\em equality-respecting} iff for every 
  $R(d,e)$ and $d' = d$ (according to the equality on $D_{\infty}$) it also is
  $R(d',e)$. 
\end{itemize}

Let use define the following bi-functor on the space of $Rel$ relations:
{\setlength{\arraycolsep}{2pt}
\[\begin{array}{lcl}
   F_{D}(R^{-},R^{+}) & = & \{ (d,e)\;\mid\;\forall \ol{d} @.@ \unroll(d) = \ret(\inj{K_1^\ar}\langle\oln{d}{\ar}\rangle) ==> \\
                   &   & \quad \exists \oln{e}{\ar} @.@ D |- e \Downarrow K_1[\taus](\ol{e}) \land (d_i,e_i) \in R^{+} \} \\ 
                   & \cup & \ldots \\ 
                   & \cup & \{ (d,e)\;\mid\;\forall d_0 @.@ \unroll(d) = \ret(\inj{->}(d_0)) ==> \\ 
                   &   & \quad \exists v @.@ D |- e \Downarrow v \;\land \\ 
                   &  & \quad\quad \forall (d',e') \in R^{-} @.@ (\dapp(d,d'),v\;e') \in R^{+} \}  \\
                   & \cup & \{ (d,e)\;\mid\; \unroll(d) = \ret(\inj{bad}(1)) ==> \\ 
                   &   & \quad D |- e \Downarrow @BAD@ \} 
\end{array}\]}
It is easy to confirm that this is indeed a bifunctor. Moreover the intersection of admissible relations
is also admissible, so we may apply {\em minimal invariance} [Pitts, Freyd] to show that there exists a 
unique fixpoint of this functor, call it $F_{D}^\infty$ and this fixpoint is isomorphic to $F_{D}(F_D^\infty,F_D^\infty)$.
We proceed with some auxiliary lemmas about $F_{D}^\infty$. 

\begin{lemma}\label{lem:bot-in-fix}
$(\roll(\bot),e) \in F_{D}^\infty$. \end{lemma}

\begin{lemma}\label{lem:eval-respecting}
If $(d,e) \in F_{D}^\infty$ and $D |- e \Downarrow v$ then $(d,v) \in F_{D}^\infty$.
Moreover, if $(d,v) \in F_{D}^\infty$ and $D |- e \Downarrow v$ then $(d,e) \in F_{D}^\infty$.
\end{lemma}
\begin{proof}
For the first part, 
if $(d,e) \in F_{D}^\infty$ then $(d,e) \in F_{D}(F_{D}^\infty,F_{D}^\infty)$. 
By the definition of $F_{D}(\cdot,\cdot)$ and by rule \rulename{EVal} the 
result follows. The second part is a similar case analysis.
\end{proof}

\begin{lemma}[Fundamental theorem for expressions]\label{lem:fund-thm-exp}
For all $\sigma$ such that $(\sigma(f),f\;[\taus]) \in F_D^\infty$ and 
all $\rho$ and vectors of closed terms $\ol{e}$ such that $(\rho(x_i),e_i) \in F_D^\infty$ 
and all $e$ with free variables in $\ol{x}$ it must be the case 
that $(\interp{e}{\sigma}{\rho},e[\ol{e}/\ol{x}]) \in F_D^\infty$.
\end{lemma}
\begin{proof} The proof is by induction on $e$. 
\begin{itemize}
  \item Case $e = x_i$ for some $x_i \in \ol{x}$ follows by the assumptions.
  \item Case $e = f\;[\taus]$ for some $f$ follows by assumptions.
  \item Case $e = K^\ar[\taus](\oln{e'}{\ar})$. By induction hypothesis we 
  have that for each $e'_i$ it is $(\interp{e'_i}{\sigma}{\rho},e'_i[\ol{e}/\ol{x}]) \in F_D^\infty$ and 
  by using rule \rulename{EVal} we are done since 
      \[ \interp{K^{\ar}[\taus](\oln{e'}{\ar})}{\sigma}{\rho} = \roll(\ret(\inj{K}(\langle\ol{\interp{e'_i}{\sigma}{\rho}}\rangle))) \]
  \item Case $e = @BAD@$ follows by unfolding definitions.
  \item Case $e = e_1\;e_2$. We need to show that
     \[ (\interp{e_1\;e_2}{\sigma}{\rho},e_1[\ol{e}/\ol{x}]\;e_2[\ol{e}/\ol{x}]) \in F_D^\infty \] 
  By induction hypothesis we have that 
  \begin{eqnarray}
     (\interp{e_1}{\sigma}{\rho},e_1[\ol{e}/\ol{x}]) \in F_D^\infty \label{eqn:e1} \\ 
     (\interp{e_2}{\sigma}{\rho},e_2[\ol{e}/\ol{x}]) \in F_D^\infty \label{eqn:e2}
  \end{eqnarray}
  Equation~\ref{eqn:e1} gives four cases: First, if $\interp{e_1}{\sigma}{\rho} = \roll(\bot)$ then we 
  are done since $\dapp(\bot,\_) = \roll(\bot)$ and $(\roll(\bot), e_1\;e_2) \in F_D^\infty$ by Lemma~\ref{lem:bot-in-fix}.
  Second, if $\interp{e_1}{\sigma}{\rho} = \roll(\ret(\inj{K}(\langle\ol{d}\rangle)))$ for some constructor
  $K$ then $\dapp(\interp{e_1}{\sigma}{\rho},\_) = \roll(\bot)$ and by similar reasoning as above we are done.
  Third, if $\interp{e_1}{\sigma}{\rho} = \roll(\ret(\inj{bad}(1)))$ then it must be that $D |- e_1[\ol{e}/\ol{x}] \Downarrow @BAD@$ by
  induction hypothesis, and by rule \rulename{EBadApp} we know that $D |- e_1[\ol{e}/\ol{x}]\;e_2[\ol{e}/\ol{x}] \Downarrow @BAD@$ hence, 
  by Lemma~\ref{lem:eval-respecting} we are done. The final case is the interesting one, where
  $\interp{e_1}{\sigma}{\rho} = \roll(\ret(\inj{->}(d_0)))$ in which case by induction hypothesis we know that 
  $(d_0(\interp{e_2}{\sigma}{\rho}), v\;e_2[\ol{e}/\ol{x}]) \in F_D^\infty$ for $D |- e_1[\ol{e}/\ol{x}] \Downarrow v$. But we know that 
  $v\;e_2[\ol{e}/\ol{x}]$ evaluates to a value {\em iff} $e_1[\ol{e}/\ol{x}]\;e_2[\ol{e}/\ol{x}]$ evaluates to a value and by 
  Lemma~\ref{lem:eval-respecting} we are done.
\end{itemize}
\end{proof}


\begin{lemma}[Fundamental theorem for top-level expressions]\label{lem:fund-thm-case}
For all $\sigma$ such that $(\sigma(f),f\;[\taus]) \in F_D^\infty$ and 
all $\rho$ and vectors of closed terms $\ol{e}$ such that $(\rho(x_i),e_i) \in F_D^\infty$ 
and all $u$ with free variables in $\ol{x}$ it must be the case 
that $(\interp{u}{\sigma}{\rho},u[\ol{e}/\ol{x}]) \in F_D^\infty$.
\end{lemma}
\begin{proof} By induction on $u$. If $u$ is a term $e$ then we are immediately done
by Lemma~\ref{lem:fund-thm-exp}. If $u = @case@\;e\;@of@\;\ol{K\;\ys -> e'}$ then the 
result follows by appealing to the induction hypothesis for $e$ and performing a case 
analysis on $\interp{e}{\sigma}{\rho}$ -- in the interesting case we appeal further to
Lemma~\ref{lem:fund-thm-exp} for a matching $e_K$ and the evaluation-respecting lemma, 
Lemma~\ref{lem:eval-respecting}.
\end{proof}

Finally, for the recursive functions environment $D$ we prove the following.
\begin{lemma} For any $f$, $(\dbrace{D}^\infty(f),f\;[\taus]) \in F_D^\infty$. \end{lemma}
\begin{proof}
Since $F_D^\infty$ is itself an {\em admissible} relation, we need only prove that:
\[ \forall i @.@ \forall f @.@ (\dbrace{D}^i(f),f\;[\taus]) \in F_D^\infty \] 
which we do by induction on $i$. For $i = 0$ we are immediately done by Lemma~\ref{lem:bot-in-fix}.
Let us assume that the property is true for $i$. We must show it is true for $i+1$. That is, 
we must show that $(\dbrace{D}^{i+1}(f),f\;[\taus]) \in F_D^\infty$. Hence, if $f$ has arity $n$, by
the definition of $\dbrace{D}$ and the definition of the logical relation it is enough to show that
for all $(\oln{d}{n},\oln{e}{n}) \in F_D^\infty$ it must be the case that 
\[    (\interp{u}{\dbrace{D}^i}{\ol{x |-> d}}, u[\ol{e}/\ol{x}]) \in F_D^\infty \] 
for $f |-> (\Lambda\as @.@ \lambda\oln{x{:}\tau}{n} @.@ u) \in D$. But that follows by 
Lemma~\ref{lem:fund-thm-case}, since by induction hypothesis it is the case that for 
every $f$ we have $(\dbrace{D}^i(f),f\;[\ol{\tau}]) \in F_D^\infty$.
\end{proof} 

\begin{corollary}\label{cor:fund-thm-top}
For every closed expression $e$ in $D$ (not-necessarily well-typed) we have that 
$(\interp{e}{\dbrace{D}^\infty}{\cdot}, e) \in F_D^\infty$. 
\end{corollary}

From this corollary, adequacy follows by unfolding definitions.

\begin{corollary}[Model-based-reasoning]
If $\Sigma |- D$ and $\Sigma;\cdot |- e_1 : \tau$ and $\Sigma;\cdot |- e_2 : \tau$, 
then for every closed $e$ such that $\Sigma |- D$ and $\Sigma;\cdot |- e : \tau -> Bool$,
if $\interp{e_1}{\dbrace{D}^\infty}{\cdot} = \interp{e_2}{\dbrace{D}^\infty}{\cdot}$ then  
$D |- e\;e_1 \Downarrow$ iff $D |- e\;e_2 \Downarrow$. 
\end{corollary}
\begin{proof}
For one direction assume that $D |- e\;e_1 \Downarrow w$, hence by computational soundness it must be that 
$\interp{e\;e_1}{\dbrace{D}^\infty}{\cdot} = \roll(\ret(d))$. By assumptions we must also 
have that $\interp{e\;e_2}{\dbrace{D}^\infty}{\cdot} = \roll(\ret(d))$. By the fundamental theorem 
we know that 
\[ (\interp{e\;e_2}{\dbrace{D}^\infty}{\cdot}, e\;e_2) \in F_{D}^\infty \] 
and hence $D |- e\;e_2 \Downarrow$. The other direction is symmetric.
\end{proof}

%% \begin{lemma}[Evaluation preserves equality]
%% If $\Sigma;\cdot |- e : \tau \rightsquigarrow t$ and 
%%    $\Sigma |- D \rightsquigarrow \phi_{\Sigma,D}$ and 
%%    $D |- e \Downarrow w$ then
%%    $\Sigma;\cdot |- w : \tau \rightsquigarrow s$ and $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- t = s$.
%% \end{lemma}
%% \begin{proof} By induction on the evaluation $\Sigma |- e \Downarrow w$. \end{proof}


%% \begin{lemma}[Logic deduces sound value equalities]
%% Assume that $\Sigma;\cdot |- w : \tau \rightsquigarrow t$ and 
%% $D |- value(w)$ and $\Sigma |- D \rightsquigarrow \phi_{\Sigma,D}$. 
%% Then
%% \begin{enumerate*} 
%%   \item If $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- t = \bad$ then $w = @BAD@$.
%%   \item If $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- t = K(\ol{t})$ then $w = K[\taus](\ol{e})$, such 
%%         that $\Sigma;\cdot |- \ol{e : \tau} \rightsquigarrow \ol{s}$, and $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- \ol{t = s}$.
%%   \item $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- t \neq \unr$.
%% \end{enumerate*}
%% \end{lemma}
%% \begin{proof}
%% The proof of all three cases is by inversion on the $D |- value(w)$ derivation, 
%% apealling to the disjointness axioms.
%% %% \begin{enumerate*}
%% %%   \item By inversion on the $D |- value(w)$ derivation. In the case of \rulename{VBad} we are done.
%% %%   The case of \rulename{VFun} cannot happen, by the axiom set \rulename{AxPartB}. The case of \rulename{VCon} 
%% %%   cannot happen either: If the application is saturated then \rulename{AxDisjC} shows it is impossible; if it
%% %%   is not saturated we can always extend it and use \rulename{AxAppC} and \rulename{AxDisjC}. 
%% %%   \item Again by inversion on $D |- value(w)$ derivation. The case of \rulename{VBad} is easy. The case for 
%% %%   \rulename{VCon} follows by injectivity of constructors. The case of \rulename{VFun} can't happen by 
%% %%   \rulename{AxPartB}.
%% %%   \item Direct inversion on $D |- value(w)$, and using disjointness axioms.
%% %% \end{enumerate*} 
%% \end{proof}
 
%% Basic soundness will be stated as follows.
%% \begin{theorem}
%% If we have that
%% \begin{enumerate*} 
%%   \item $\Sigma;\cdot |- e : \tau$ and $\Sigma;\cdot |- \Ct : \tau$
%%   \item $\Sigma |- D \rightsquigarrow \phi_{\Sigma,D}$
%%   \item $\Sigma;\cdot |- e \in \Ct \rightsquigarrow \phi$
%% \end{enumerate*}
%% and $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} /\ \neg \phi$ is unsatisfiable then $\Sigma;D |- e \in \Ct$.
%% \end{theorem}
%% \begin{proof}
%%  {\bf TODO}
%% \end{proof}

%% A remark: a formula $\phi$ is unsatisfiable iff $\neg \phi$ is valid in FOL. Hence, if 
%% $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} /\ \neg \phi$ is unsatisfiable then 
%% $\neg (\Th{\Sigma}{D} /\ \phi_{\Sigma,D}) \lor \phi$ must be valid, and by completeness of FOL, 
%% $\Th{\Sigma}{D} /\ \phi_{\Sigma,D} |- \phi$.  


\section{Induction and admissibility}
{\bf TODO} 


\section{Minimization}
{\bf TODO} 

\section{Some ideas}
Sometimes the $\CF$ contract stands in our way e.g. for library stuff. It might 
be interesting to explore some user-defined pragma to side-step the $\bad$ case
in some pattern matches (i.e. make it on demand, pretty much as $F^{\star}$ does, where
only the user's assertions matter.
%% \acks
%% Acknowledgements here

\end{document}
